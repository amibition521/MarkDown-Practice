### JVM 虚拟机

1.内存管理机制

![image](https://github.com/amibition521/MarkDown-Practice/raw/master/interview/ic/006tKfTcgw1fb913k1wc0j30f50a53zv.jpg)

各个区域介绍：    
![image](https://github.com/amibition521/MarkDown-Practice/raw/master/interview/ic/006tKfTcgw1fb91bux68qj31f016w41s.jpg)

2.垃圾收集算法

主要思考的问题:

* 标记-那些内存(那些死,那些活着)需要回收?
* 什么时候回收?
* 如何回收?

2.1.标记算法

* 引用计数法（废弃）

  每当一个地方引用它时,计数器+1,引用失效时,计数器-1,任何时刻计数器为0的对象就是不可能在被使用

  java没有用 最主要的原因很难解决对象之间互相循环引用的问题;

* 可达性分析算法
  * Java 语言中,可作为GC Roots的对象包括下面几种;
    * 虚拟机栈中(栈帧中的本地变量表)的引用对象
    * 方法区中类静态属性引用对象
    * 方法区中类常量引用对象
    * 本地方法栈JNI引用的对象

2.2.四种引用：

* 强引用:类似Object obj=new Object() 这类引用,只要强引用还在,垃圾收集器就永远不会回收被引用的对象;
* 软引用:用来描述一些还有用但并未必须的对象。内存溢出异常之前,会把这些对象列入回收范围之内进行二次回收。如果回收后还没有足够的内存这回OOM;
* 弱引用:用来描述非必须的对象。若引用关联的对象只能活到下一次垃圾回收之前;
* 虚引用:唯一目的对象被回收时收到一个系统通知

2.3 不可达对象的最后历程

```
finalize()方法不执行或者只能执行一次
```

不可达对象,也并非"非死不可" 这时候是在缓刑阶段。要真正宣告死亡,至少要经理两次标记过程。
如果对象进行可达性分析后发现没有GC Roots相关联的引用链,会被第一次标记并且进行一次筛选,筛选条件是此对象是否有必要执行finalize()方法。
对象没有覆盖finalize方法(逃脱命运的最后机会),或者**finalize()方法被虚拟机掉用过(只能执行一次)**,虚拟机将这两种情况都视为"没有必要执行"
如果被判定有必要执行,那么对象会放置叫一个F-Queue的队列之中,并且稍后虚拟机自动建立Finalize线程去执行它既finalize方法
但并不承诺会等待他运行结束,怕死循环或者运行缓慢。finalize方法是逃脱命运的最后机会,如果没有逃脱就真的被回收了;

2.4  垃圾收集算法

2.4.1  标记-清除算法（基础）

​	标记：标记所有需要回收的对象

​	清除：统一回收所有被标记的对象

​	缺点：

​	1.效率问题，标记和清除效率都不高

​	2.空间问题，产生大量的不连续的内存碎片

2.4.2 复制算法

内存容量划分两个大小相等的两块,每次使用其中的一块。这块用完了复制存活的对象到另一块,在把这块清理掉

不足：把内存缩小为原来的一半。

现代的商用虚拟街都采用这种算法来回收新生代：因为新生代都是 **朝生暮死** 所以不需要1:1来划分，而将内存分为一块较大的Eden 和两个较小的Survivor 默认大小比;8:1：1, 每次新生代中可用的内存空间是整个新生代容量的90=(Eden+Survivor), 
"浪费" 10 因为没办法保证回收只有不多于10的存活,Survivor空间不够需要老年代进行 担保;

2.4.3 标记-整理算法(Mark-Compace)（老年代常用）

标记和以前一样,后续步骤不是直接回收,而是存活对象向一端移动,然后清理边界以外的内存;

2.4.4 分代收集算法

根据对象存活周期将内存划分不同的几块。一般堆分为 新生代 和老年代。这样根据年代的特点采用最适当的收集算法

新生代:少量存活 选择复制算法

老年代:存活率高,没有额外空间担保,必须使用 标记清理 或者标记整理;

关于安全点另一个需要考虑的就是如何在GC发生的时让所有线程都"跑"到最近的安全点上在停下来;有两种方案

抢先式中断(Preemptive Suspension)(现在几乎都这种方案):不需要线程的执行代码主动配合,GC发生时候先把线程全部中断,如果有线程不在安全点,就回复线程让它跑到安全点。

主动式中断(Voluntary Suspension):当GC需要中断线程的时候,不对线程造作,仅仅简单地设置一个标志位,各个线程执行的时候主动去轮询这个标志位,发现中断标志位真就挂起,轮询标志的地方安全点重合。
而对于不执行的线程,任何时间都是安全的也称为安全区;

3 垃圾收集器

![image](https://github.com/amibition521/MarkDown-Practice/raw/master/interview/ic/006tKfTcgw1fb9166bymyj30e00b5wfn.jpg)



* Serial:单线程收集器，在进行垃圾收集时，必须要暂停其他所有的工作线程，直到它收集结束。

> 1. 需要STW（Stop The World），停顿时间长。
> 2. 简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。

* ParNew:是Serial的多线程版本，除了使用多线程进行垃圾收集外，其他行为与Serial完全一样

> Tips：1.Server模式下虚拟机的首选新生收集器，与CMS进行搭配使用。

* Parallel Scavenge:目标是达到一个可控制的吞吐量，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)，高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务，并且虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应调节策略。
* Serial Old:老年代的单线程收集器，使用标记 - 整理算法，
* Parallel Old:老年代的多线程收集器，使用标记 - 整理算法，吞吐量优先，适合于Parallel Scavenge搭配使用
* CMS（Conrrurent Mark Sweep）收集器是以获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法，收集过程分为如下四步：
  - 初始标记，标记GCRoots能直接关联到的对象，时间很短。
  - 并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。
  - 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。
  - 并发清除，回收内存空间，时间很长。 >其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行 >Tips：1. 对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。

> 1. 无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。
> 2. 由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。

\* GC类型

* Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。
* Major GC:指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC，同时Minor GC也会引起Major GC，一般在GC日志中统称为GC，不频繁。
* Full GC:指发生在老年代和新生代的GC，速度很慢，需要Stop The World。

大对象直接进入老年代:大对象就是大量连续内存空间的Java对象,典型的就是很长的字符串及数组。并且内存超过虚拟机设置大对象的值;

长期存活的对象进入老年代:jvm给每个对象定义一个对象年龄计数器。如果eden出生并经过第一次Minor GC后仍然存活并且能被Survivor容纳的话,将被移动到Survivor空间并将对象年龄设为1.对象在Survivor区每"熬过"一次Minor GC则年龄+1,当年龄达到一定程度(默认15岁),下一次将会被晋升老年代。

动态对象年龄判定:为了更好的适应内存状况。如果在Survivor空间中相同年龄的所有对象大小的综合大于Survivor的一半,那么大于等于这个年龄的将被一起带入老年代

4.虚拟机参数设置

代码的运行参数设置为： -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8

![image](https://github.com/amibition521/MarkDown-Practice/raw/master/interview/ic/616953-20160226111115693-1490327308.png)

5.Java线程调度

* 协同式调度

  执行时间由线程本身来控制，把自己工作执行完后主动通知系统切换到另一个线程。

  缺点：如果线程出现堵塞那么所有都堵塞。

* 抢占式调度 

  系统分配时间，切换不由线程本身来决定。

  Thread.yield()可以让出执行时间.获取时间则没有办法;

  额外知识 ++不是原子性,AtomicInteger CAS(原子性)来避免阻塞同步;
