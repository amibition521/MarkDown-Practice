### Java 虚拟机

Q1.内存模型

* 堆

  1.如何实现的？

  * 新生代
    * eden区
    * suivivor区
      * S0和S1 或者from 和to
    * eden、from、to的内存的大小默认是8:1:1
  * 老年代
  * 永久代

![image](https://github.com/amibition521/MarkDown-Practice/raw/master/interview/ic/006tKfTcgw1fb916pqo7bj30lm09taas.jpg)

* 栈
* 程序计数器
* 方法区
* 1.7 永久代
* 1.8 metaspace

Q2.对象在内存中的初始化过程？

要初始化一个对象，首先要加载该对象所对应的class文件，该文件的数据会被加载到永久代，并创建一个底层的instanceClass对象代表该class，再为将要初始化的对象分配内存空间，优先在线程私有内存空间中分配大小，如果空间不足，再到eden中进行内存分配...

Q3.YGC 过程 ？

先找出根对象，如Java栈中引用的对象、静态变量引用的对象和系统词典中引用的对象等待，把这些对象标记成活跃对象，并复制到to区，接着遍历这些活跃对象中引用的对象并标记，找出老年代对象在eden区有引用关系的对象并标记，最后把这些标记的对象复制到to，在复制过程还要判断活跃对象的gc年龄是否已经达到阈值，如果已经达到阈值，就直接晋升到老年代，YGC结束之后把from和to的引用互换

晋升失败如何处理?

Q4.volatile关键字

* 内存可见性
* 禁止内存重排序

分别解释一下：

在虚拟机内存中有主内存和工作内存的概念，每个cpu都有自己的工作内存，当读取一个普通变量时，优先读取工作内存的变量，如果工作内存中没有对应的变量，则从主内存中加载到工作内存，对工作内存的普通变量进行修改，不会立马同步到主内存，内存可见性保证了在多线程的场景下，保证了线程A对变量的修改，其它线程可以读到最新值

如何保证？

当对volatile修饰的变量进行写操作时，直接把最新值写到主内存中，并清空其它cpu工作内存中该变量所在的内存行数据，当对volatile修饰的变量进行读操作时，会读取主内存的数据

Q5.finalize

* 实现原理

  新建一个对象时，在JVM中会判断该对象对应的类是否重写了finalize方法，且finalize方法体不为空，则把该对象封装成Finalizer对象，并添加到Finalizer链表。

  Finalizer类中会初始化一个FinalizerThread类型的线程，负责从一个引用队列中获取Finalizer对象，并执行该Finalizer对象的runFinalizer方法，最终会执行原始对象的finalize方法

* 验证finalize方法是否会执行？

  初始化一个大数组，可以明显看出gc之后是否被回收，然后执行System.gc()，在finalize方法中输出信息

Q6.线程池

1.实现原理？

* 阻塞队列

  （1）如果队列满了，怎么办？

  如果队列满了，我们不是设置了最大线程数是10么，而线程池中只有5个线程，这时会新建一个线程去执行不能保存到阻塞队列的任务，

  （2）如果线程池中的线程数达到10个了，阻塞队列也满了，怎么办？

  这种情况通过自定义reject函数去处理这里任务了

  （3）阻塞队列中的任务也执行完了，线程池中的线程会怎么样？

2.线程池中的coreNum和maxNum有什么区别？

* 核心线程数
* 最大线程数

3.在不同的业务场景中，线程池参数如何设置？

Q7.锁

* Synchronized 

  Synchronized是JVM实现的一种锁，其中锁的获取和释放分别是monitorenter和monitorexit指令，该锁在实现上分为了偏向锁、轻量级锁和重量级锁，其中偏向锁在1.6是默认开启的，轻量级锁在多线程竞争的情况下会膨胀成重量级锁，有关锁的数据都保存在对象头中

* ReentranLock

  ReentrantLock是基于AQS实现的

  * AQS是什么？

    在AQS内部会保存一个状态变量state，通过CAS修改该变量的值，修改成功的线程表示获取到该锁，没有修改成功，或者发现状态state已经是加锁状态，则通过一个Waiter对象封装线程，添加到等待队列中，并挂起等待被唤醒

  * CAS的实现原理?

    CAS是通过unsafe类的compareAndSwap方法实现的.

  * compareAndrSwap参数的含义？

    第一个参数是要修改的对象，第二个参数是对象中要修改变量的偏移量，第三个参数是修改之前的值，第四个参数是预想修改后的值

* 读写锁

Q8.Map

* HashMap
  * 实现原理
* HashTable
* ConcurrnetHashMap
  * 实现原理
    * 分段锁
    * 1.8之后，红黑树
